dtmc  // Discrete-time Markov chain

// Global bounds and thresholds
const int MAX_TIME = 1000;   // Time horizon (steps)
const int MAX_BAT  = 1000;   // Battery capacity (1000 = 100%)
const int LOW_BAT  = 300;    // Early-return threshold (30%)

// Global probabilities
const double p_detect  = 0.991;  // AprilTag detection at a waypoint
const double p_coll    = 0.097;  // Collision during motion
const double p_recover = 0.902;  // Successful recovery after collision

// Energy costs applied only on successful move
const int cost_01       = 117;   // Move 0→1
const int cost_12       = 97;    // Move 1→2
const int cost_23       = 97;    // Move 2→3
const int cost_34       = 113;   // Move 3→4
const int cost_45       = 118;   // Move 4→5
const int cost_56       = 109;   // Move 5→6
const int cost_dock     = 124;   // Move 6→0 (end-of-cycle dock)
const int cost_dock_soc = 101;   // Low-SoC direct dock
const int cost_recover  = 10;    // Recovery action cost

// Convenience guards
formula CAN_MOVE   = phase=0 & !collided & t<MAX_TIME & bat>LOW_BAT;            // Eligible to move while patrolling
formula CAN_DETECT = phase=0 & !collided & t<MAX_TIME & bat>LOW_BAT & !scanned; // Eligible to scan once per waypoint

module robot
    phase    : [0..2] init 0;        // 0=patrol, 1=docked/success, 2=failed
    wp       : [0..6] init 0;        // Current waypoint (0 is dock)
    bat      : [0..MAX_BAT] init MAX_BAT;  // Remaining battery
    t        : [0..MAX_TIME] init 0; // Elapsed steps
    collided : bool init false;      // Collision latch until recovered
    scanned  : bool init false;      // True after a scan at current wp

    // Per-tag observation flags
    seen1 : bool init false;
    seen2 : bool init false;
    seen3 : bool init false;
    seen4 : bool init false;
    seen5 : bool init false;
    seen6 : bool init false;

    // Movement steps.
    [move_01] CAN_MOVE & wp=0 & bat>=cost_01 ->
        p_coll     : (collided'=true) & (t'=t+1)               // Collision: no progress, no move cost
      + (1-p_coll) : (wp'=1) & (bat'=bat-cost_01) & (t'=t+1);  // Success: advance, pay cost

    [move_12] CAN_MOVE & wp=1 & bat>=cost_12 & scanned ->
        p_coll     : (collided'=true) & (t'=t+1)
      + (1-p_coll) : (wp'=2) & (scanned'=false) & (bat'=bat-cost_12) & (t'=t+1); // Reset scanned for next wp

    [move_23] CAN_MOVE & wp=2 & bat>=cost_23 & scanned ->
        p_coll     : (collided'=true) & (t'=t+1)
      + (1-p_coll) : (wp'=3) & (scanned'=false) & (bat'=bat-cost_23) & (t'=t+1);

    [move_34] CAN_MOVE & wp=3 & bat>=cost_34 & scanned ->
        p_coll     : (collided'=true) & (t'=t+1)
      + (1-p_coll) : (wp'=4) & (scanned'=false) & (bat'=bat-cost_34) & (t'=t+1);

    [move_45] CAN_MOVE & wp=4 & bat>=cost_45 & scanned ->
        p_coll     : (collided'=true) & (t'=t+1)
      + (1-p_coll) : (wp'=5) & (scanned'=false) & (bat'=bat-cost_45) & (t'=t+1);

    [move_56] CAN_MOVE & wp=5 & bat>=cost_56 & scanned ->
        p_coll     : (collided'=true) & (t'=t+1)
      + (1-p_coll) : (wp'=6) & (scanned'=false) & (bat'=bat-cost_56) & (t'=t+1);

    [move_dock] CAN_MOVE & wp=6 & bat>=cost_dock & scanned ->
        p_coll     : (collided'=true) & (t'=t+1)
      + (1-p_coll) : (wp'=0) & (phase'=1) & (bat'=bat-cost_dock) & (t'=t+1); // Complete patrol on docking

    // Low-SoC docking path; only available when not collided. Carries collision risk.
    [move_dock_soc] phase=0 & !collided & bat<=LOW_BAT & bat>=cost_dock_soc & t<MAX_TIME ->
        p_coll     : (collided'=true) & (t'=t+1)
      + (1-p_coll) : (phase'=1) & (wp'=0) & (bat'=bat-cost_dock_soc) & (t'=t+1);

    // Collision recovery; consumes cost either way.
    [recover] phase=0 & collided & bat>=cost_recover & t<MAX_TIME ->
        p_recover     : (collided'=false) & (bat'=bat-cost_recover) & (t'=t+1)  // Recovery succeeds
      + (1-p_recover) : (phase'=2)        & (bat'=bat-cost_recover) & (t'=t+1); // Recovery fails → failure

    // Tag scans; one attempt per wp. Success marks seen_i.
    [scan_1] CAN_DETECT & wp=1 -> p_detect:(seen1'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_2] CAN_DETECT & wp=2 -> p_detect:(seen2'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_3] CAN_DETECT & wp=3 -> p_detect:(seen3'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_4] CAN_DETECT & wp=4 -> p_detect:(seen4'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_5] CAN_DETECT & wp=5 -> p_detect:(seen5'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_6] CAN_DETECT & wp=6 -> p_detect:(seen6'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);

    // Failure guards for timeouts and insufficient SoC to act
    [fail_time]        phase=0 & t >= MAX_TIME -> (phase'=2);
    [fail_soc_recover] phase=0 & collided  & bat < cost_recover  -> (phase'=2);
    [fail_soc_dock]    phase=0 & !collided & bat < cost_dock_soc -> (phase'=2);

    // Absorbing self-loops for terminal states
    [docked] phase=1 -> (phase'=1);
    [failed] phase=2 -> (phase'=2);
endmodule

// Terminal reward equals energy used so far
rewards "energy"
    (phase=1 | phase=2) : MAX_BAT - bat;
endrewards

// Property macros
formula tag_success       = seen1 & seen2 & seen3 & seen4 & seen5 & seen6;  // All tags found
formula nav_docked        = (phase = 1 & wp = 0);                           // Docked at wp0
formula nav_failed        = (phase = 2);                                    // Entered failure
formula nav_terminal      = (nav_docked | nav_failed);                      // Any terminal outcome
formula mission_success   = (nav_docked & tag_success);                     // Docked with all tags
formula mission_safe_fail = (nav_docked & !tag_success);                    // Docked without all tags
