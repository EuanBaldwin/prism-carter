// Model: Autonomous warehouse patrol robot DTMC with battery, perception, and recovery logic.

// Purpose: 
//   Abstract a strict ordered patrol (dock→1→2→3→4→5→6→dock) to evaluate
//   navigation success, tag-detection success, early docking on low SoC, and
//   failure due to recovery or resource/time limits.

// State summary:
//   phase ∈ {0,1,2}: 0=patrol (ongoing), 1=docked (absorbing), 2=failure (absorbing).
//   wp ∈ {0..6}:     Current waypoint (0=dock/start). Patrol order is linear 0→…→6.
//   bat ∈ {0..MAX}:  Battery units (1 unit = 0.1% SoC). Costs are debited on actions.
//   t ∈ {0..T}:      Discrete time steps; each move/scan/recovery increments t by 1.
//   recovery (bool): Latch indicating we are in a recovery subroutine after a collision.
//   scanned (bool):  Enforces scan attempt per waypoint; resets on movement.
//   already_docking,set_bat_low (bool): Latches to ensure a clean low-SoC docking path.
//   seen{1..6} (bool): Per-waypoint tag detections.

// Action summary:
//   move_ij: attempt to traverse edge i→j; may trigger recovery; consumes cost_ij on success.
//   scan_k:  single Bernoulli tag-detection attempt at waypoint k.
//   recovery: try to resolve a collision; success clears latch; failure absorbs to phase=2.
//   soc_bat_low / move_dock_soc: structured early-docking path at/under LOW_BAT.
//   move_dock: final leg from wp=6 to dock; may itself trigger recovery.

// Termination:
//   Success when phase=1 (returned_to_dock). Failure on timeout, insufficient SoC for
//   mandated action, or failed recovery. Reward encodes total SoC consumed at termination.

// Assumptions:
//   Segment-specific recovery triggers are Bernoulli per move (memoryless abstraction).
//   Patrol moves only proceed if post-move SoC would remain ≥ LOW_BAT (reserve policy).
//   Docking leg requires bat≥cost_dock; it may also suffer a recovery event.

dtmc  // Discrete-time Markov chain

// --------------------------------- Global constants ---------------------------------

const int    MAX_TIME           = 100;     // Time horizon (steps) for the patrol episode
const int    MAX_BAT            = 1000;    // Battery capacity (1 unit = 0.1% SoC; 1000 = 100%)
const int    LOW_BAT            = 200;     // Reserve threshold (20%) that triggers early docking
const double p_detect           = 0.99988; // Per-waypoint AprilTag detection success
const double p_recovery_success = 0.9852;  // Probability that a recovery attempt resolves safely

// Probability that a recovery is triggered on move_ij
const double p_recovery_01   = 0.043;
const double p_recovery_12   = 0.040;
const double p_recovery_23   = 0.039;
const double p_recovery_34   = 0.046;
const double p_recovery_45   = 0.051;
const double p_recovery_56   = 0.050;
const double p_recovery_dock = 0.060;

// Energy costs applied on successful move_ij
const int cost_01       = 120;
const int cost_12       = 114;
const int cost_23       = 112;
const int cost_34       = 126;
const int cost_45       = 136;
const int cost_56       = 134;
const int cost_dock     = 153;
const int cost_recovery = 36;

// -------------------------------- Convenience guards --------------------------------

// afford_next: true iff, at current wp, we can pay the next patrol leg and still keep ≥LOW_BAT.
//              Docking is exempt from the reserve (only requires bat≥cost_dock).
formula afford_next = (wp=0 & bat>=(cost_01+LOW_BAT)) | (wp=1 & bat>=(cost_12+LOW_BAT)) | (wp=2 & bat>=(cost_23+LOW_BAT)) | 
                      (wp=3 & bat>=(cost_34+LOW_BAT)) | (wp=4 & bat>=(cost_45+LOW_BAT)) | (wp=5 & bat>=(cost_56+LOW_BAT)) | (wp=6 & bat>=cost_dock);

// can_move:     general eligibility to traverse the next patrol edge (no recovery active,
//               within horizon, above low-SoC threshold, and preserving reserve via afford_next).
formula can_move        = phase=0 & !recovery & t<MAX_TIME & bat>LOW_BAT & afford_next;

// can_detect:   exactly one scan attempt per wp, only while above low-SoC threshold.
formula can_detect      = phase=0 & !recovery & t<MAX_TIME & bat>LOW_BAT & !scanned;

// docking_low_soc: early-docking entry when (i) at or below LOW_BAT, or (ii) cannot afford
//                  the next patrol leg after completing scans; requires bat≥cost_dock.
formula docking_soc = phase=0 & !recovery & t<MAX_TIME & bat>=cost_dock & (bat<=LOW_BAT | ((wp=0 | scanned) & !afford_next));

// ----------------------------------- Robot Module -----------------------------------

module robot
    phase           : [0..2] init 0;             // 0=patrol (transient), 1=docked (absorbing), 2=failed (absorbing)
    wp              : [0..6] init 0;             // Current waypoint (0 is dock/home). Patrol proceeds linearly to 6.
    bat             : [0..MAX_BAT] init MAX_BAT; // Remaining battery units; debited by movement/recovery/dock actions
    t               : [0..MAX_TIME] init 0;      // Elapsed discrete time; every enabled action increments by 1
    recovery        : bool init false;           // Latch set true after a recovery trigger until resolved or failed
    scanned         : bool init false;           // Latch set true after attempting the scan at the current wp
    already_docking : bool init false;           // Latch to persist non-SoC docking once initiated
    set_bat_low     : bool init false;           // Clamp SoC to LOW_BAT before executing low-SoC docking

    // Per-tag observation flags (mission-level perception outcomes)
    seen1 : bool init false;
    seen2 : bool init false;
    seen3 : bool init false;
    seen4 : bool init false;
    seen5 : bool init false;
    seen6 : bool init false;

    // Movement steps. On each patrol edge, either:
    // (i)  a recovery is triggered (enter recovery subroutine, no SoC move cost yet),
    // (ii) the move succeeds, consuming the edge-specific energy cost and advancing wp; scanned resets upon arrival.
    // Note: move_01 is allowed without a scan at wp=0 (dock has no tag), whereas subsequent moves require scanned=true.
    [move_01] can_move & wp=0           -> p_recovery_01:(recovery'=true)&(t'=t+1) + (1-p_recovery_01):(wp'=1)&(bat'=bat-cost_01)&(t'=t+1);
    [move_12] can_move & wp=1 & scanned -> p_recovery_12:(recovery'=true)&(t'=t+1) + (1-p_recovery_12):(wp'=2)&(bat'=bat-cost_12)&(t'=t+1)&(scanned'=false);
    [move_23] can_move & wp=2 & scanned -> p_recovery_23:(recovery'=true)&(t'=t+1) + (1-p_recovery_23):(wp'=3)&(bat'=bat-cost_23)&(t'=t+1)&(scanned'=false);
    [move_34] can_move & wp=3 & scanned -> p_recovery_34:(recovery'=true)&(t'=t+1) + (1-p_recovery_34):(wp'=4)&(bat'=bat-cost_34)&(t'=t+1)&(scanned'=false);
    [move_45] can_move & wp=4 & scanned -> p_recovery_45:(recovery'=true)&(t'=t+1) + (1-p_recovery_45):(wp'=5)&(bat'=bat-cost_45)&(t'=t+1)&(scanned'=false);
    [move_56] can_move & wp=5 & scanned -> p_recovery_56:(recovery'=true)&(t'=t+1) + (1-p_recovery_56):(wp'=6)&(bat'=bat-cost_56)&(t'=t+1)&(scanned'=false);

    // Docking leg from wp=6 to dock (success). The already_docking latch ensures that, if a recovery is 
    // triggered on the dock edge, we resume docking afterward (rather than re-evaluating the low-SoC policy).
    [move_dock] phase=0 & !recovery & t<MAX_TIME & wp=6 & scanned & bat>=cost_dock & (bat>LOW_BAT | already_docking) ->
        p_recovery_dock     : (recovery'=true) & (already_docking'=true) & (t'=t+1)
      + (1-p_recovery_dock) : (wp'=0) & (phase'=1) & (bat'=bat-cost_dock) & (already_docking'=false) & (t'=t+1); // Complete patrol on docking

    // Low-SoC docking path; only available when not collided. Carries recovery-trigger risk.
    // First clamp the battery to LOW_BAT (accounting convention), then attempt docking.
    [soc_bat_low] docking_soc & !already_docking & !set_bat_low -> (bat'=LOW_BAT) & (set_bat_low'=true);

    [move_dock_soc] docking_soc & !already_docking & set_bat_low ->
        p_recovery_dock     : (recovery'=true) & (t'=t+1) 
      + (1-p_recovery_dock) : (phase'=1) & (wp'=0) & (bat'=bat-cost_dock) & (t'=t+1);

    // Recovery; consumes cost either way (attempt made), succeeds with p_recovery_success.
    // On failure, we enter the absorbing failure phase and set bat=0 to reflect depletion/abort.
    [recovery] phase=0 & recovery & bat>=cost_recovery & t<MAX_TIME ->
        p_recovery_success     : (recovery'=false) & (bat'=bat-cost_recovery) & (t'=t+1)  // Recovery succeeds
      + (1-p_recovery_success) : (phase'=2)        & (bat'=0)                 & (t'=t+1); // Recovery fails → failure

    // Tag scans; one attempt per wp (k∈{1..6}). Success sets seen_k.
    [scan_1] can_detect & wp=1 -> p_detect:(seen1'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_2] can_detect & wp=2 -> p_detect:(seen2'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_3] can_detect & wp=3 -> p_detect:(seen3'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_4] can_detect & wp=4 -> p_detect:(seen4'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_5] can_detect & wp=5 -> p_detect:(seen5'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);
    [scan_6] can_detect & wp=6 -> p_detect:(seen6'=true)&(scanned'=true)&(t'=t+1) + (1-p_detect):(scanned'=true)&(t'=t+1);

    // Failure guards for timeouts and insufficient SoC to act.
    [fail_time]        phase=0 & t >= MAX_TIME                   -> (phase'=2);              // Time horizon exceeded before reaching a terminal outcome.
    [fail_soc_recover] phase=0 & recovery  & bat < cost_recovery -> (phase'=2) & (bat' = 0); // Can't afford the recovery attempt when required.
    [fail_soc_dock]    phase=0 & !recovery & bat < cost_dock     -> (phase'=2) & (bat' = 0); // Can't afford the docking leg when required.

    // Absorbing self-loops for terminal states
    [docked] phase=1 -> (phase'=1);
    [failed] phase=2 -> (phase'=2);
endmodule

// ------------------------ Reward: Total SoC cost of the run -------------------------

rewards "cost_total"
  nav_terminal : MAX_BAT - bat;
endrewards

// ----------------- Property labels for readability in PCTL queries ------------------

formula docked            = (phase = 1);                                   // Successful docking at WP 0 (mission end)
formula all_wp            = (wp = 6);                                      // Reached wp6 and performed its scan (i.e., visited all WPs)
formula all_tags          = seen1 & seen2 & seen3 & seen4 & seen5 & seen6; // All six tags detected
formula mission_success   = (docked & all_tags);                           // Successful docking with complete tag set
formula terminal_low_soc  = (bat <= LOW_BAT);                              // Mission terminates with low SoC
formula terminal_zero_soc = (bat <= 0);                                    // Mission terminates with zero SoC
formula docking_low_soc   = (docking_soc & !already_docking);              // Low SoC docking is triggered
formula docking_failed    = (phase = 2);                                   // Any failure outcome (timeout, SoC, recovery failure)
formula nav_terminal      = (docked | docking_failed);                     // Predicate for termination (success or failure)
